[%
    scr_arr = [
      'https://d3js.org/d3-fetch.v1.min.js',
    #  'https://d3js.org/d3.v5.min.js',
    #  'https://unpkg.com/dc@4/dist/dc.js',
      'https://cdnjs.cloudflare.com/ajax/libs/crossfilter2/1.5.2/crossfilter.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.14.1/cytoscape.min.js',
    ]

    page_title = 'Cytoscape Demo';

    PROCESS 'views/inc/macros.tt';
    PROCESS 'views/inc/js.tt';
    WRAPPER 'views/inc/page_wrapper.tt';

    cytoscape_content = PROCESS cytoscape;

    page_content = [
        {
          name              => "Cytoscape Demo",
          name_lc           => "graph_demo",
          rendered_content  => cytoscape_content,
        },
    ];

    tabbed_layout( page_content = page_content );

    BLOCK cytoscape  %]
    <div class="container-fluid">
      <div class="row">
        <div id="cy" style="height: 1000px" class="col-md-10"></div>
        <div id="controls" class="col-md-2">
          <h2>Data</h2>
          <div class="form-group" id="dataset--div"></div>
          <h2>Layout</h2>
          <div class="form-group" id="layout--div"></div>
          <div class="form-group" id="layout_fit--div">
            <button id="layout_fit--button" class="btn layout_fit--button">
              Fit to viewport
            </button>
          </div>
          <div class="form-group" id="layout_reset--div">
            <button id="layout_reset--button" class="btn layout_reset--button">
              Reset layout
            </button>
          </div>
          <h2>Selection</h2>
          <div class="form-group">
            <button id="select_all--button" class="btn">
              Select All
            </button>
            <button id="select_none--button" class="btn">
              Select None
            </button>
            <button id="select_invert--button" class="btn">
              Invert selection
            </button>
          </div>
          <div class="form-group">
            <!-- If enabled along with panning, the user must hold down one of shift, control, alt, or command to initiate box selection. -->
            <button id="select_box--button" class="btn">
              Toggle box selection
            </button>
            <button id="select_multiple--button" class="btn">
              Toggle multiple selection
            </button>
          </div>
          <ul>
            <li>get neighbourhood of selected nodes</li>
            <li>select nodes from ID list</li>
            <li>select nodes by edge metadata</li>
            <li>select nodes by node metadata</li>
          </ul>
          <h2>Export</h2>
          <div class="form-group">
            <button id="export_json--button" class="btn">
              Export as JSON
            </button>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-md-12">
          <table id="metadata"></table>
        </div>
      </div>
    </div>
[%
    END;
%]
<script>
  "use strict";

  function renderGraph(element_id, node_arr, edge_arr) {
    const graph = cytoscape({
      container: document.getElementById(element_id), // container to render in
      elements: {
        nodes: node_arr,
        edges: edge_arr,
      },
      layout: layouts['random'],

      // so we can see the ids
      style: [
        {
          selector: 'node',
          style: {
            'width': 10,
            'height': 10,
            'shape': 'ellipse', // (ellipse/rectangle/round-diamond),
          }
        },
        {
          selector: 'node:selected',
          style: {
              "border-width": 2,
              "border-style": "solid",
              "border-color": "#3f3f3f",
              "border-opacity": 1,
              "background-color": '#900',
              'label': 'data(id)'
          },
        },
        {
          selector: 'node.phenotype',
          style: {
            'width': 50,
            'height': 50,
            'shape': 'round-diamond',
          },
        },
        {
          selector: 'edge',
          style: {
            'width': 3,
            'line-color': '#ccc',
          }
        }
      ],
    })
    return graph
  }


  const layouts = {
    random: {
      name: 'random',

      fit: true, // whether to fit to viewport
      padding: 30, // fit padding
      boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      animate: false, // whether to transition the node positions
      animationDuration: 500, // duration of animation in ms if enabled
      animationEasing: undefined, // easing of animation if enabled
      animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined, // callback on layoutready
      stop: undefined, // callback on layoutstop
      transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts
    },
    grid: {
      name: 'grid',

      fit: true, // whether to fit the viewport to the graph
      padding: 30, // padding used on fit
      boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
      avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
      nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
      spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
      condense: false, // uses all available space on false, uses minimal space on true
      rows: undefined, // force num of rows in the grid
      cols: undefined, // force num of columns in the grid
      position: function( node ){}, // returns { row, col } for element
      sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
      animate: false, // whether to transition the node positions
      animationDuration: 500, // duration of animation in ms if enabled
      animationEasing: undefined, // easing of animation if enabled
      animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined, // callback on layoutready
      stop: undefined, // callback on layoutstop
      transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts
    },
    circle: {
      name: 'circle',
      fit: true, // whether to fit the viewport to the graph
      padding: 30, // the padding on fit
      boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
      nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
      spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
      radius: undefined, // the radius of the circle
      startAngle: 3 / 2 * Math.PI, // where nodes start in radians
      sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
      clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
      sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
      animate: false, // whether to transition the node positions
      animationDuration: 500, // duration of animation in ms if enabled
      animationEasing: undefined, // easing of animation if enabled
      animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined, // callback on layoutready
      stop: undefined, // callback on layoutstop
      transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts
    },

    concentric: {
      name: 'concentric',

      fit: true, // whether to fit the viewport to the graph
      padding: 30, // the padding on fit
      startAngle: 3 / 2 * Math.PI, // where nodes start in radians
      sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
      clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
      equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
      minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
      boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
      nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
      height: undefined, // height of layout area (overrides container height)
      width: undefined, // width of layout area (overrides container width)
      spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
      concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre
        return node.degree();
      },
      levelWidth: function( nodes ){ // the letiation of concentric values in each level
        return nodes.maxDegree() / 4;
      },
      animate: false, // whether to transition the node positions
      animationDuration: 500, // duration of animation in ms if enabled
      animationEasing: undefined, // easing of animation if enabled
      animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
      ready: undefined, // callback on layoutready
      stop: undefined, // callback on layoutstop
      transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts
    },
    cose: {
      name: 'cose',

      // Called on `layoutready`
      ready: function(){},

      // Called on `layoutstop`
      stop: function(){},

      // Whether to animate while running the layout
      // true : Animate continuously as the layout is running
      // false : Just show the end result
      // 'end' : Animate with the end result, from the initial positions to the end positions
      animate: true,

      // Easing of the animation for animate:'end'
      animationEasing: undefined,

      // The duration of the animation for animate:'end'
      animationDuration: undefined,

      // A function that determines whether the node should be animated
      // All nodes animated by default on animate enabled
      // Non-animated nodes are positioned immediately when the layout starts
      animateFilter: function ( node, i ){ return true; },


      // The layout animates only after this many milliseconds for animate:true
      // (prevents flashing on fast runs)
      animationThreshold: 250,

      // Number of iterations between consecutive screen positions update
      refresh: 20,

      // Whether to fit the network view after when done
      fit: true,

      // Padding on fit
      padding: 30,

      // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
      boundingBox: undefined,

      // Excludes the label when calculating node bounding boxes for the layout algorithm
      nodeDimensionsIncludeLabels: false,

      // Randomize the initial positions of the nodes (true) or use existing positions (false)
      randomize: false,

      // Extra spacing between components in non-compound graphs
      componentSpacing: 40,

      // Node repulsion (non overlapping) multiplier
      nodeRepulsion: function( node ){ return 2048; },

      // Node repulsion (overlapping) multiplier
      nodeOverlap: 4,

      // Ideal edge (non nested) length
      idealEdgeLength: function( edge ){ return 32; },

      // Divisor to compute edge forces
      edgeElasticity: function( edge ){ return 32; },

      // Nesting factor (multiplier) to compute ideal edge length for nested edges
      nestingFactor: 1.2,

      // Gravity force (constant)
      gravity: 1,

      // Maximum number of iterations to perform
      numIter: 1000,

      // Initial temperature (maximum node displacement)
      initialTemp: 1000,

      // Cooling factor (how the temperature is reduced between consecutive iterations
      coolingFactor: 0.99,

      // Lower temperature threshold (below this point the layout will end)
      minTemp: 1.0
    }
  },
  dir = '/static/cytoscape/',
  json_files = {
    'djornl_tiny.json': 'Cut-down version of the literature dataset',
    'djornl_pheno_assn.json': 'GWAS associations produced by analyzing a subset of phenotypes and SNPs in the Arabidopsis 1001 Genomes database (13,918 nodes, 40864 edges; phenotype data)',
    'djornl_domain_co_occur.json': 'protein domain co-occurrence values from the Arabidopsis AraNetv2 database (7634 nodes, 25000 edges)',
    'djornl_gene_coexpr.json': 'pairwise gene coexpression values from the Arabidopsis AraNetv2 database (10,307 nodes, 50095 edges)',
    'djornl_ppi_liter.json': 'protein-protein interaction values from literature-curated small- to medium-scale experimental data; from the Arabidopsis AraNetv2 database (2709 nodes, 5168 edges)',
    'djornl_ppi_hithru.json': 'protein-protein interaction values derived from four high-throughput PPI screening experiments; from the Arabidopsis AraNetv2 database (4216 nodes, 8000 edges)',
  },
  gene_data = 'djornl_gene.json',
  pheno_data = 'djornl_phenotype.json',
  graph_el_id = 'cy'

  addLayoutSelector(layouts)
  addDatasetSelector(json_files)

  function load_dataset(file_name) {
    let files_to_load = [file_name, gene_data]
    if (file_name.indexOf('pheno') !== -1) {
      // load both phenotype and gene info
      files_to_load.push(pheno_data)
    }
    let promises = files_to_load.map(d => d3.json(dir + d))

    Promise.all(promises)
    .then(all_file_data =>  {
      let data = {
        nodes: {},
        edges: {},
        node_data: {},
        genes: {},
      }
      // do we have phenotype data?
      const pheno_data = all_file_data.length === 3 ? 1 : 0

      all_file_data[0].forEach(d => {
        // the first file keys:
        // _from, _to, lls, _key, _id
        const obj = {
          source: d._from,
          target: d._to,
          edge: d.lls,
          id: d._key,
        }

        const node_list = ['_from', '_to']

        node_list.forEach( n => {
          if (data.nodes[d[n]]) {
            data.nodes[d[n]].push(obj)
          }
          else {
            data.nodes[d[n]] = [obj]
          }
        })
        data.edges[obj.id] = obj
      })

      const pheno_fields = ["pheno_aragwas_id", "pheno_ref", "pheno_desc1", "pheno_desc2", "pheno_desc3"]
      // second file: gene data
      all_file_data[1].forEach(d => {
        // normalise the accessor
        d.id = d._id
        if (data.nodes[d.id]) {
          data.node_data[d.id] = d
        }
      })

      if (all_file_data[2]) {
        // phenotype data
        data['pheno'] = {}
        all_file_data[2].forEach(d => {
          d.id = d._id
          data.pheno[d._id] = d
          data.node_data[d._id] = d
        })
      }
      window.data = data

      data.node_arr = Object.keys(data.nodes).map(el => { return { data: { id: data.node_data[el]._id } } } )
      data.edge_arr = Object.keys(data.edges).map(el => { return { data: data.edges[el] } } )

      console.log('Found ' + data.node_arr.length + ' nodes and ' + data.edge_arr.length + ' edges')
      const cy = renderGraph('cy', data.node_arr, data.edge_arr)

      let collection = cy.collection()
      cy.nodes().on('click', function(e){
        let node = e.target
        collection = collection.union(node)
        // display metadata
        if (node.selected()){
          console.log(data.node_data[node.id()])
        }
      })

      cy.nodes().forEach( n => {
        let node_id = n.data()['id']
        data.node_data[ node_id ]['degree'] = n.degree()
        n.data(data.node_data[ node_id ])
        if (pheno_data) {
          if (data.pheno[ node_id ]) {
            // this is a phenotype
            n.data({
              type: 'phenotype'
            })
            n.addClass('phenotype')
          }
        }
      })

      $('#layout--select').change( (eventData,handler) => {
        const value = $('#layout--select').val()
        const layout = cy.layout( layouts[value] )
        layout.run()
      })
      $('#layout_reset--button').click( () => { cy.reset() } )
      $('#layout_fit--button').click( () => { cy.fit() } )
      $('#select_all--button').click( () => { cy.nodes().forEach( e => e.select() ) } )
      $('#select_none--button').click( () => { cy.nodes().forEach( e => e.unselect() ) } )
      $('#select_invert--button').click( () => {
        cy.nodes().forEach( e => e.selected()
          ? e.unselect()
          : e.select()
        )
      } )
      $('#select_multi--button').click( () => { cy.selectionType() === 'single'
        ? cy.selectionType('additive')
        : cy.selectionType('single')
      } )
      $('#select_box--button').click( () => { cy.boxSelectionEnabled( !cy.boxSelectionEnabled() ) } )
      window.cy = cy
    })
  }


//           > First Neighbors of Selected Nodes
//           > Select nodes from ID list
//           > Select nodes by edge metadata/properties
//           > Invert selection
//           > Select by mouse

  function addDatasetSelector(json_files) {
    // insert an options element with each of the layouts above
    const dataset_arr = Object.keys(json_files).map( (f,i) => {
      return '<option value="' + f + '"'
      //  + ( i ? '' : ' selected' )
        + '>' + json_files[f] + '</option>'
    }),
    dataset_str = '<select id="dataset--select" class="form-control" name="dataset">'
      + '<option selected>Select a data set to view</option>'
      + dataset_arr.join('\n')
      + '</select>'
    $('#dataset--div').append(dataset_str)
    $('#dataset--select').change( (eventData, handler) => {
      const value = $('#dataset--select').val()
      if (value) {
        load_dataset(value)
      }
      else {
        // remove the graph?
      }
    })
  }

  function addLayoutSelector(layouts) {
    // insert an options element with each of the layouts above
    const layout_arr = Object.keys(layouts).map( (layout,i) => {
      return '<option value="' + layout + '"'
        + ( i ? '' : ' selected' )
        + '>' + layout + '</option>'
    }),
    select_str = '<select id="layout--select" class="form-control" name="layout">' + layout_arr.join('\n') + '</select>'
    $('#layout--div').append(select_str)
  }

</script>
[%
    END; # end wrapper

%]
